(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{406:function(a,s,e){"use strict";e.r(s);var t=e(56),n=Object(t.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[a._v("#")]),a._v(" 变量")]),a._v(" "),e("p",[a._v("javascript的变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只是一个用于保存任意值命名的占位符。有三种方式可以声明变量： "),e("strong",[a._v("var")]),a._v("、"),e("strong",[a._v("let")]),a._v("和"),e("strong",[a._v("const")]),a._v("。")]),a._v(" "),e("h2",{attrs:{id:"_1、var"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、var"}},[a._v("#")]),a._v(" 1、var")]),a._v(" "),e("p",[e("code",[a._v("var message")]),e("br"),a._v("\n以上就定义了一个message的变量了，你可以当即赋值，也可以之后再赋值")]),a._v(" "),e("h4",{attrs:{id:"_1-1-var-声明作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-var-声明作用域"}},[a._v("#")]),a._v(" 1.1 var 声明作用域")]),a._v(" "),e("p",[a._v("使用var定义的变量会成为包含它的函数的局部变量：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function test() {\n    var message = 'nihao';\n}\ntest();\nconsole.log(message); //报错\n")])])]),e("p",[a._v("在全局作用域声明的变量会成为window对象的属性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var message = 'nihao';\nconsole.log(message); //nihao\nconsole.log(window.message); //nihao\n")])])]),e("h4",{attrs:{id:"_1-2-var-声明提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-var-声明提升"}},[a._v("#")]),a._v(" 1.2 var 声明提升")]),a._v(" "),e("p",[a._v("使用var声明变量时，会将你的对这个关键字的声明提升到函数作用域的顶部（但是赋值不会提升）：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function test1() {\n    console.log(message);\n    var message = 'nihaoya';\n}\ntest1(); //undefined\n")])])]),e("p",[a._v("因为变量提升，所以不会有报错，可以看做是")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function test1() {\n    var message;\n    console.log(message);\n    message = 'nihaoya';\n}\ntest1(); //undefined\n")])])]),e("h4",{attrs:{id:"_1-3-var-重复声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-var-重复声明"}},[a._v("#")]),a._v(" 1.3 var 重复声明")]),a._v(" "),e("p",[a._v("使用var反复声明同一个变量不会有问题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var message = 'nihao';\nvar message = 'woshi';\nvar message = 'azhu';\nconsole.log(message);  // azhu\n")])])]),e("h2",{attrs:{id:"_2、let"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、let"}},[a._v("#")]),a._v(" 2、let")]),a._v(" "),e("p",[a._v("let 和 var的作用类似，都是用来声明一个变量，但是二者有着很重要区别")]),a._v(" "),e("h4",{attrs:{id:"_2-1-let的声明作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-let的声明作用域"}},[a._v("#")]),a._v(" 2.1 let的声明作用域")]),a._v(" "),e("p",[a._v("let声明的范围是块级作用域，和var的函数作用域不同：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    {\n        var a = 'nihao';\n    }\n    console.log(a) //nihao\n    {\n        let b = 'woshi';\n    }\n    console.log(a) //报错\n")])])]),e("h4",{attrs:{id:"_2-2-let-暂时性死区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-let-暂时性死区"}},[a._v("#")]),a._v(" 2.2 let 暂时性死区")]),a._v(" "),e("p",[a._v("使用let声明变量时，会并不会对你的声明进行提升，所以你在使用let声明变量之前调用这个变量将会报错：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(a);//undefined\nvar a = 'nihaoya';\n\nconsole.log(b);//报错\nlet b = 'nihaoya';\n")])])]),e("p",[a._v("这是因为在let声明之前的执行瞬间会形成“暂时性死区”（temporal dead zone）,在这段let声明代码之前引用该变量都会报错。")]),a._v(" "),e("h4",{attrs:{id:"_2-3-let-全局声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-let-全局声明"}},[a._v("#")]),a._v(" 2.3 let 全局声明")]),a._v(" "),e("p",[a._v("和var不同，let在全局声明的变量不会成为window对象的属性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let message = 'nihao';\nconsole.log(message); //nihao\nconsole.log(window.message); //undefined\n")])])]),e("h4",{attrs:{id:"_2-4-let-重复声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-let-重复声明"}},[a._v("#")]),a._v(" 2.4 let 重复声明")]),a._v(" "),e("p",[a._v("let 在同一块级作用域内不可重复声明，var虽然可以重复声明，但不可以同let一起对单个变量进行重复声明：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let message = 'nihao';\nlet message = 'woshi';//报错\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let message = 'nihao';\nvar message = 'woshi';//报错\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var message = 'woshi';\nlet message = 'nihao';//报错\n")])])]),e("h2",{attrs:{id:"_3、const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、const"}},[a._v("#")]),a._v(" 3、const")]),a._v(" "),e("p",[a._v("const和let的用法基本相同，唯一的区别是const在声明变量时必须赋值，而且不能对const声明的变量"),e("strong",[a._v("指向")]),a._v("进行修改：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let message；\nconsole.log(message);//undefined\nconst message1;//报错\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("const message = 'nihao';\nmessage = 'nihaoya';//报错\nconst person = {name: 'azhu'};\nperson.name = lm; //ok\nconst person1 = {name1: 'azhu'};\nperson1 = {sex: 'men'}; //报错\n")])])]),e("p",[a._v("如果const声明的变量是一个对象数据，改变这个对象的内部属性并不违反const限制，只要你不改变这个对象的指向就可以")])])}),[],!1,null,null,null);s.default=n.exports}}]);