(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{412:function(t,e,n){"use strict";n.r(e);var o=n(56),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),n("p",[t._v("基本数据类型有：number,string,boolean,object,null,undefined,symbol")]),t._v(" "),n("ul",[n("li",[t._v("简单类型：数值类型，字符串类型，boolean类型，null，undefined, symbol")]),t._v(" "),n("li",[t._v("对象类型：除了以上六种，剩下都是对象类型")])]),t._v(" "),n("h1",{attrs:{id:"类型判断"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类型判断"}},[t._v("#")]),t._v(" 类型判断")]),t._v(" "),n("h3",{attrs:{id:"_1-typeof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-typeof"}},[t._v("#")]),t._v(" 1.typeof")]),t._v(" "),n("p",[t._v("可判断的类型有："),n("code",[t._v("number/string/boolean/undefined/object/function/symbol")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("typeof(xxx)\n")])])]),n("p",[t._v("ps: null类型会判断为object")]),t._v(" "),n("h3",{attrs:{id:"_2-instanceof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-instanceof"}},[t._v("#")]),t._v(" 2. instanceof")]),t._v(" "),n("p",[t._v("instanceof是利用原型链来判断构造函数的prototype指向的对象是否在obj对象的原型链上，可用来判断数组、正则等"),n("br"),t._v("\n手写：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const ownInstanceof = (target, origin) => {\n    //非object直接返回false\n    if(typeof target !== 'object' || target === null) return false\n    //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象\n    var proto = Object.getPrototypeOf(target);\n    while(proto) {\n        if(proto === origin.prototype) {\n            return true\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n    return false\n}\n")])])]),n("h3",{attrs:{id:"_3-object-prototype-tostring"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-object-prototype-tostring"}},[t._v("#")]),t._v(" 3. Object.prototype.toString")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const arr = [1, 2, 3];\nconsole.log(Object.prototype.toString.call(arr)) //"[object Array]"\n')])])]),n("p",[t._v("call是用来改变toString方法的执行上下文(this指向)，从而获得对象的内置属性，可用apply代替")]),t._v(" "),n("p",[t._v("扩展: Object.prototype.toString可以判断函数是同步还是异步")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('//promise  \nvar promise1 = new Promise((resolve,reject) => {\n    resolve();\n})\nconsole.log(Object.prototype.toString.call(promise1))  //"[object Promise]"  \n\n//async\nasync function fun() {\n    await 2\n}\nconsole.log(Object.prototype.toString.call(fun)) //"[object AsyncFunction]"  \n\n//同步函数\nfunction fun1() {\n    alert(\'1\')\n}\nconsole.log(Object.prototype.toString.call(fun1))  //"[object Function]"\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);